{"version":3,"file":"content.js","sources":["../src/audio-notifier.ts","../src/badge-notifier.ts","../src/retry-with-delay.ts","../src/watcher/process-chunk-results.ts","../src/watcher/detector.ts","../src/watcher/get-transcript.ts","../src/watcher/player-control.ts","../src/watcher/index.ts","../src/content.ts"],"sourcesContent":["export const createAudioNotifier = () => {\n  const audioPlayer = new Audio();\n  audioPlayer.src = chrome.runtime.getURL(\"found.mp3\");\n  audioPlayer.pause();\n\n  return {\n    play() {\n      audioPlayer.currentTime = 0;\n      audioPlayer.play();\n    },\n  };\n};\n","import { ClientState } from \"./client-state\";\nimport { ClientMessage } from \"./extension-message\";\nimport { log } from \"./log\";\n\nexport const triggerBadgeUpdate = (\n  clientState: ClientState,\n  publish: (message: ClientMessage) => void\n) => {\n  log(\"triggerBadgeUpdate\", { clientState });\n  if (clientState.tabStatus === \"processing\") {\n    publish({\n      type: \"action:update-badge\",\n      text: clientState.foundSponsoredTimestamps.length.toString() || \"...\",\n      color: \"blue\",\n    });\n    return;\n  }\n  if (clientState.isBlockerEnabled) {\n    publish({\n      type: \"action:update-badge\",\n      text: clientState.foundSponsoredTimestamps.length.toString() || \"on\",\n      color: \"green\",\n    });\n    return;\n  } else {\n    publish({\n      type: \"action:update-badge\",\n      text: \"off\",\n      color: \"#333\",\n    });\n    return;\n  }\n};\n","import { log } from \"./log\";\nimport { wait } from \"./wait\";\n\nexport const retryPromiseWithDelay = async <T>(\n  promise: () => Promise<T>,\n  delay: number,\n  retries = 3,\n  onError?: (error: any) => void\n): Promise<T> => {\n  try {\n    return await promise();\n  } catch (error) {\n    if (retries === 0) throw error;\n    await wait(delay);\n    if (onError) onError(error);\n\n    log(`Retrying ${retries} more times...`);\n    return await retryPromiseWithDelay(promise, delay, retries - 1);\n  }\n};\n","import {\n  ChunkResult,\n  ChunkSponsoredFoundResult,\n  SponsoredTimestamp,\n} from \"./detector\";\n\nexport const processChunkResults = (\n  results: ChunkResult[],\n  minLength: number = 1,\n  minDistance: number = 0\n) => {\n  const isFound = (\n    chunkResult: ChunkResult\n  ): chunkResult is ChunkSponsoredFoundResult => chunkResult.isSponsoredFound;\n\n  const isLongEnough = (chunkResult: SponsoredTimestamp) => {\n    const duration = chunkResult.endSeconds - chunkResult.startSeconds;\n    return duration >= minLength;\n  };\n\n  const mergeCloseChunks = (\n    timestamps: SponsoredTimestamp[],\n    chunkResult: ChunkSponsoredFoundResult\n  ) => {\n    const lastTimestamp = timestamps[timestamps.length - 1];\n    if (!lastTimestamp) {\n      return [\n        {\n          startSeconds: chunkResult.startSeconds,\n          endSeconds: chunkResult.endSeconds,\n        },\n      ];\n    }\n    const distance = chunkResult.startSeconds - lastTimestamp.endSeconds;\n    if (distance <= minDistance) {\n      const mergedTimestamp: SponsoredTimestamp = {\n        startSeconds: lastTimestamp.startSeconds,\n        endSeconds: chunkResult.endSeconds,\n      };\n\n      return [...timestamps.slice(0, timestamps.length - 1), mergedTimestamp];\n    }\n\n    return [\n      ...timestamps,\n      {\n        startSeconds: chunkResult.startSeconds,\n        endSeconds: chunkResult.endSeconds,\n      },\n    ];\n  };\n  // TODO: merge overlapping/close chunks\n  const sponsoredTimestamps = results\n    .filter(isFound)\n    .reduce(mergeCloseChunks, [])\n    .filter(isLongEnough)\n    .map((result) => {\n      return {\n        startSeconds: result.startSeconds,\n        endSeconds: result.endSeconds,\n      };\n    });\n\n  return sponsoredTimestamps;\n};\n","import { log } from \"../log\";\nimport { TranscriptLine } from \".\";\nimport { retryPromiseWithDelay } from \"../retry-with-delay\";\nimport { processChunkResults } from \"./process-chunk-results\";\n\nconst round = (num: number) => Math.round(num * 100) / 100;\nconst formatLine = (line: TranscriptLine) =>\n  `${round(line.offsetSeconds)}s\\t${line.text}`;\n\nconst makePromptForChunk = (chunk: string) =>\n  `\nThis is a video transcript with each line in format:\n\n<time in seconds>\\t<text>\n\n== video transcript chunk start ==\n\n${chunk}\n\n== video transcript chunk end ==\n\nThe video transcript can contain sponsored segments.\nSponsored segments often start with phrases such as \"I want to thank our sponsor\" or \"this video is sponsored by\"\n\nAnswer the following questions in JSON format:\n\n1. Does this transcript contain sponsored content?\n2. If so, when does the sponsored content start?\n3. If so, when does the sponsored content end?\n\nReply in this format (JSON): \n{ \"isSponsoredFound\": boolean, startSeconds: number, endSeconds: number }\n`.trim();\n\nconst makeAnalyseChunkRequest = async (chunk: string, apiKey: string) => {\n  return fetch(\"https://api.openai.com/v1/chat/completions\", {\n    method: \"POST\",\n    headers: {\n      \"Content-Type\": \"application/json\",\n      Authorization: `Bearer ${apiKey}`,\n    },\n    body: JSON.stringify({\n      model: \"gpt-3.5-turbo\",\n      messages: [{ role: \"user\", content: chunk }],\n    }),\n  })\n    .then((response) => response.json())\n    .catch((error) => {\n      console.error(error);\n      return null;\n    });\n};\n\nexport type ChunkSponsoredFoundResult = {\n  index: number;\n  isSponsoredFound: true;\n  startSeconds: number;\n  endSeconds: number;\n};\nexport type ChunkSponsoredNotFoundResult = {\n  index: number;\n  isSponsoredFound: false;\n};\n\nexport type ChunkResult =\n  | ChunkSponsoredFoundResult\n  | ChunkSponsoredNotFoundResult;\n// Analyze each chunk and look for sponsored content mentions\nasync function analyzeChunk(\n  chunk: string,\n  index: number,\n  apiKey: string\n): Promise<ChunkResult> {\n  const prompt = makePromptForChunk(chunk);\n\n  const response = await makeAnalyseChunkRequest(prompt, apiKey);\n  if (!response) return { isSponsoredFound: false, index };\n  const resultText = response.choices[0]?.message?.content;\n\n  if (resultText === \"not found\") {\n    return { isSponsoredFound: false, index };\n  }\n\n  const { isSponsoredFound, startSeconds, endSeconds } = JSON.parse(\n    resultText\n  ) as Partial<ChunkSponsoredFoundResult>;\n\n  if (!isSponsoredFound) return { isSponsoredFound: false, index };\n  if (typeof startSeconds !== \"number\" || typeof endSeconds !== \"number\")\n    return { isSponsoredFound: false, index };\n\n  return { isSponsoredFound, startSeconds, endSeconds, index };\n}\n\nconst splitTranscript = (\n  transcriptLines: string[],\n  maxTokens: number,\n  overlap: number\n) => {\n  let chunks = [];\n  let currentLineIndex = 0;\n  let currentChunkIndex = 0;\n  const maxChunkLength = maxTokens - overlap;\n\n  while (currentLineIndex < transcriptLines.length) {\n    if (!chunks[currentChunkIndex]) {\n      chunks[currentChunkIndex] = \"\";\n    }\n\n    if (chunks[currentChunkIndex].length > maxChunkLength) {\n      currentChunkIndex++;\n      continue;\n    }\n\n    const currentLine = transcriptLines[currentLineIndex];\n    chunks[currentChunkIndex] = `${chunks[currentChunkIndex]}\\n${currentLine}`;\n    currentLineIndex++;\n  }\n\n  return chunks.map((chunk) => chunk.trim());\n};\n\nexport type SponsoredTimestamp = {\n  startSeconds: number;\n  endSeconds: number;\n};\n\nexport const detectSponsoredContent = async (\n  transcript: TranscriptLine[],\n  apiKey: string\n): Promise<SponsoredTimestamp[]> => {\n  const promptLength = makePromptForChunk(\"\").length;\n  const maxTokens = 4096 - promptLength; // GPT-3.5's maximum tokens per request\n  const overlap = 100; // Overlap between chunks to ensure continuity\n\n  const transcriptLines = transcript.map(formatLine);\n\n  log(\"transcriptLines\", transcriptLines.join(\"\\n\"));\n  const chunks = splitTranscript(transcriptLines, maxTokens, overlap);\n\n  console.time(\"analyzeChunk\");\n\n  return Promise.all(\n    chunks.map((chunk, ind) => {\n      log(`analyzing chunk ${ind} of ${chunks.length}`, { chunk });\n      return retryPromiseWithDelay(\n        () =>\n          analyzeChunk(chunk, ind, apiKey).then((result) => {\n            log(`analyzed chunk ${ind} of ${chunks.length}`);\n            return result;\n          }),\n        1000,\n        3,\n        (error) => {\n          log(`analyzing chunk ${ind} of ${chunks.length} failed`, {\n            error,\n            chunk,\n          });\n        }\n      );\n    })\n  ).then((results) => {\n    console.timeEnd(\"analyzeChunk\");\n    return processChunkResults(results, 30, 70);\n  });\n};\n","import { TranscriptLine } from \".\";\nimport { log } from \"../log\";\n\nexport const getTranscript = async () => {\n  const videoID = new URL(location.href).searchParams.get(\"v\");\n\n  const transcript = await fetch(\n    `https://butter-api-gamma.vercel.app/api/transcriptions?id=${videoID}`,\n    {\n      mode: \"cors\",\n    }\n  )\n    .then((res) => res.json() as Promise<{ transcript: TranscriptLine[] }>)\n    .then(({ transcript }) => transcript);\n\n  log(\"transcript\", transcript);\n\n  return transcript;\n};\n","import { SponsoredTimestamp } from \"./detector\";\n\nexport const createPlayerControl = (\n  el: HTMLVideoElement,\n  timestamps: SponsoredTimestamp[],\n  onSponsoredTimestampEnter: (segment: SponsoredTimestamp) => void\n) => {\n  if (!timestamps.length) return () => {};\n  let previousTimestamp: SponsoredTimestamp | null = null;\n\n  const interval = setInterval(() => {\n    const currentTime = el.currentTime;\n\n    const currentTimestamp = timestamps.find(({ startSeconds, endSeconds }) => {\n      return currentTime >= startSeconds && currentTime <= endSeconds;\n    });\n\n    if (currentTimestamp && previousTimestamp !== currentTimestamp) {\n      previousTimestamp = currentTimestamp;\n      onSponsoredTimestampEnter(currentTimestamp);\n      el.currentTime = currentTimestamp.endSeconds;\n    }\n  }, 500);\n\n  return () => clearInterval(interval);\n};\n","import { log } from \"../log\";\nimport { SponsoredTimestamp, detectSponsoredContent } from \"./detector\";\nimport { getTranscript } from \"./get-transcript\";\nimport { createPlayerControl } from \"./player-control\";\n\nexport type TranscriptLine = {\n  text: string;\n  offsetSeconds: number;\n  durationSeconds: number;\n};\n\nconst createLocationObserver = (callback: () => void) => {\n  let lastURL = location.href;\n  let timer = setInterval(() => {\n    if (location.href !== lastURL) {\n      lastURL = location.href;\n      callback();\n    }\n  }, 1000);\n\n  return () => clearInterval(timer);\n};\n\nexport const createWatcher = ({\n  onTimestampsUpdate,\n  onProcessingStart,\n  onProcessingError,\n  onProcessingComplete,\n  onSponsoredTimestampEnter,\n}: {\n  onTimestampsUpdate: (timestamps: SponsoredTimestamp[]) => void;\n  onSponsoredTimestampEnter: (timestamp: SponsoredTimestamp) => void;\n  onProcessingStart: () => void;\n  onProcessingError: (error: Error) => void;\n  onProcessingComplete: () => void;\n}) => {\n  let destroyPlayerControl: () => void = () => {};\n\n  const start = async (openAIAPIKey: string) => {\n    const processCurrentPage = async () => {\n      log(\"processing current page\");\n\n      onTimestampsUpdate([]);\n      destroyPlayerControl();\n\n      const transcript = await getTranscript();\n\n      const sponsoredTimestamps = await detectSponsoredContent(\n        transcript,\n        openAIAPIKey\n      );\n\n      onTimestampsUpdate(sponsoredTimestamps);\n\n      log(\"sponsoredTimestamps\", sponsoredTimestamps);\n\n      const videoElement = document.querySelector(\"video\");\n      if (!videoElement) throw new Error(\"Cannot find video element\");\n\n      destroyPlayerControl = createPlayerControl(\n        videoElement,\n        sponsoredTimestamps,\n        (timestamp) => {\n          log(\"onSponsoredTimestampEnter\", timestamp);\n          onSponsoredTimestampEnter(timestamp);\n        }\n      );\n    };\n\n    onProcessingStart();\n    await processCurrentPage()\n      .then(onProcessingComplete)\n      .catch(onProcessingError);\n\n    createLocationObserver(() => {\n      log(\"video changed, processing new page...\");\n      const isVideoPlayerPage =\n        location.pathname === \"/watch\" &&\n        new URL(location.href).searchParams.get(\"v\");\n\n      if (!isVideoPlayerPage) return log(\"not a video player page, skipping\");\n\n      onProcessingStart();\n      processCurrentPage().then(onProcessingComplete).catch(onProcessingError);\n    });\n  };\n\n  return {\n    start,\n  };\n};\n","import { createAudioNotifier } from \"./audio-notifier\";\nimport { triggerBadgeUpdate } from \"./badge-notifier\";\nimport { ClientState, makeStore } from \"./client-state\";\nimport { BackgroundMessage, ClientMessage } from \"./extension-message\";\nimport { log } from \"./log\";\nimport { createWatcher } from \"./watcher\";\n\nlog(\"content script loaded\");\n\nconst store = makeStore();\n\nlet isPortConnected = false;\n\n// TODO: drop that, use subs\ntriggerBadgeUpdate(store.state, (message) => {\n  try {\n    chrome.runtime.sendMessage(message);\n  } catch (err) {\n    log(\"Failed to send message to background\", { err });\n  }\n});\n\nchrome.runtime.onConnect.addListener((port) => {\n  log(\"Port connected\");\n  isPortConnected = true;\n\n  port.postMessage({\n    type: \"content:state:update\",\n    state: store.state,\n  } as ClientMessage);\n\n  port.onMessage.addListener((message: BackgroundMessage) => {\n    log(`Received message [${message.type}]`, { message });\n\n    const audioNotification = createAudioNotifier();\n\n    const watcher = createWatcher({\n      onTimestampsUpdate: (foundSponsoredTimestamps) => {\n        updateStoreAndNotify({ foundSponsoredTimestamps });\n      },\n      onSponsoredTimestampEnter: () => {\n        audioNotification.play();\n      },\n      onProcessingStart: () => {\n        updateStoreAndNotify({ tabStatus: \"processing\" });\n      },\n      onProcessingError: (error) => {\n        // TODO: handle error, publish error state\n        log(\"Processing error\", { error });\n      },\n      onProcessingComplete: () => {\n        updateStoreAndNotify({ tabStatus: \"idle\" });\n      },\n    });\n\n    const sendMessage = (message: ClientMessage) => {\n      if (!isPortConnected) {\n        log(\"Port disconnected, ignoring message\", { message });\n        return;\n      }\n      port.postMessage(message);\n    };\n\n    const updateStoreAndNotify = (delta: Partial<ClientState>) => {\n      // TODO: replace with an observable\n\n      store.set(delta);\n      const message: ClientMessage = {\n        type: \"content:state:update\",\n        state: store.state,\n      };\n\n      sendMessage(message);\n\n      // !: hack, replace with an observable subscription\n      triggerBadgeUpdate(store.state, (message) => {\n        try {\n          chrome.runtime.sendMessage(message);\n        } catch (err) {\n          log(\"Failed to send message to background\", { err });\n        }\n      });\n    };\n\n    if (message.type === \"content:enable-blocker\") {\n      updateStoreAndNotify({ isBlockerEnabled: true });\n\n      watcher.start(message.openAIAPIKey);\n    }\n\n    if (message.type === \"content:disable-blocker\") {\n      // TODO: stop watcher instead of reloading the page\n\n      window.location.reload();\n      // updateStoreAndNotify({ isBlockerEnabled: false });\n    }\n  });\n\n  port.onDisconnect.addListener(() => {\n    isPortConnected = false;\n    log(\"Port disconnected\");\n  });\n});\n"],"names":["createAudioNotifier","audioPlayer","Audio","src","chrome","runtime","getURL","pause","play","currentTime","triggerBadgeUpdate","clientState","publish","log","tabStatus","type","text","foundSponsoredTimestamps","length","toString","color","isBlockerEnabled","retryPromiseWithDelay","promise","delay","retries","onError","error","wait","processChunkResults","results","minLength","minDistance","isFound","chunkResult","isSponsoredFound","isLongEnough","endSeconds","startSeconds","mergeCloseChunks","timestamps","lastTimestamp","mergedTimestamp","slice","sponsoredTimestamps","filter","reduce","map","result","round","num","Math","formatLine","line","offsetSeconds","makePromptForChunk","chunk","trim","makeAnalyseChunkRequest","apiKey","fetch","method","headers","Authorization","body","JSON","stringify","model","messages","role","content","then","response","json","catch","console","analyzeChunk","index","prompt","resultText","choices","message","parse","splitTranscript","transcriptLines","maxTokens","overlap","chunks","currentLineIndex","currentChunkIndex","maxChunkLength","currentLine","detectSponsoredContent","transcript","join","time","Promise","all","ind","timeEnd","getTranscript","videoID","URL","location","href","searchParams","get","mode","res","createPlayerControl","el","onSponsoredTimestampEnter","previousTimestamp","interval","setInterval","currentTimestamp","find","clearInterval","createLocationObserver","callback","lastURL","timer","createWatcher","onTimestampsUpdate","onProcessingStart","onProcessingError","onProcessingComplete","destroyPlayerControl","start","openAIAPIKey","processCurrentPage","videoElement","document","querySelector","Error","timestamp","pathname","store","makeStore","isPortConnected","state","sendMessage","err","onConnect","addListener","port","postMessage","onMessage","audioNotification","watcher","updateStoreAndNotify","delta","set","window","reload","onDisconnect"],"mappings":"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"}